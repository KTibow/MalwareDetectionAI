import Neataptic from "neataptic";
import { readFile, readdir, writeFile } from "fs/promises";

/**
 * @param {import("neataptic").Network} network
 * @param {number[]} input
 * @returns number
 */
const runNetwork = (network, input) => {
  let memory = [0, 0, 0, 0];
  let score = 0;
  const chunkSize = 6;
  for (let i = 0; i < input.length; i += chunkSize) {
    const chunk = input.slice(i, i + chunkSize);
    const output = network.activate([...chunk, ...memory]);
    score = output[0];
    memory = output.slice(1);
  }
  return score;
};
const getRandomSample = async (dir) => {
  const files = await readdir(dir);
  const fileSample = files
    .map((f) => [f, Math.random()])
    .sort((a, b) => b[1] - a[1])
    .map((i) => i[0])
    .slice(0, 5);
  return await Promise.all(fileSample.map((f) => readFile(`${dir}/${f}`)));
};
const evaluateNetwork = async (network) => {
  const [rats, clean] = await Promise.all([getRandomSample("rats"), getRandomSample("not rats")]);
  const ratScores = rats.map((i) => runNetwork(network, i));
  const ratAvg = ratScores.reduce((a, b) => a + b, 0) / rats.length;

  const cleanScores = clean.map((i) => runNetwork(network, i));
  const cleanAvg = cleanScores.reduce((a, b) => a + b, 0) / clean.length;

  console.log("rat", ratAvg, "clean", cleanAvg);
  if (isNaN(ratAvg) || isNaN(cleanAvg)) return -1;
  return ratAvg - cleanAvg;
};
const neat = new Neataptic.Neat(10, 5, (networks) => Promise.all(networks.map(evaluateNetwork)), {
  fitnessPopulation: true,
});

for (let iterations = 0; iterations < 100; iterations++) {
  console.log("=== NEW GENERATION ===");
  await neat.evolve();
  const population = neat.export();
  await writeFile(`models-${iterations}.json`, JSON.stringify(population));
}
